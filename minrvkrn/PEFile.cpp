#include "StdAfx.h"
#include "PEFile.h"
#include <algorithm>
#include <iomanip>
#include <sstream>
#include <iostream>
#include <WinTrust.h>
#include <Softpub.h>
#include <Wincrypt.h>
#include <stdlib.h>
#include <Sfc.h>
#include <time.h>
#include <ImageHlp.h>
#include "GenericFile.h"


#pragma comment(lib, "sfc")
#pragma comment(lib, "Crypt32.lib")
#pragma comment(lib, "Imagehlp.lib")
#pragma comment(lib, "Wintrust.lib")


PEFile::PEFile(void)
{
	hFile = INVALID_HANDLE_VALUE;
	hFileMapping = NULL;
	is_signed = 0;
	heur_sum = 0;
}

BOOL PEFile::OpenFile(TCHAR* filename)
{
	BOOL rc = FALSE;

	__try 
	{
		if (filename)
		{
			m_hFile = CreateFile(filename, GENERIC_READ, FILE_SHARE_READ, 0,
						OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);

			if (m_hFile != INVALID_HANDLE_VALUE)
			{
				m_hFileMapping = CreateFileMapping(m_hFile, 0, PAGE_READONLY, 
									0, 0, 0);

				if (m_hFileMapping)
				{
					m_pMappedFileBase = (BYTE *) MapViewOfFile(m_hFileMapping, 
													FILE_MAP_READ, 0, 0, 0);

					if (m_pMappedFileBase)
					{
						m_pDOSHeader   = (IMAGE_DOS_HEADER *) m_pMappedFileBase;
						m_pNTHeaders32 = (IMAGE_NT_HEADERS *) ((BYTE*)m_pDOSHeader + 
											m_pDOSHeader->e_lfanew);
						m_pNTHeaders64 = (IMAGE_NT_HEADERS64 *) m_pNTHeaders32;
						m_pImgFileHdr  = (IMAGE_FILE_HEADER *) 
											&m_pNTHeaders32->FileHeader;
						rc = TRUE;
					}
					else
					{
						_tprintf(_T("mapviewoffile failed"));
					}
				}
				else
				{
					_tprintf(_T("create file mapping failed"));
				}
			}
			else
			{
				_tprintf(_T("failed to open file. "));
				m_hFile = 0;
			}
		}
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{}

	return rc;
}

void PEFile::CloseFile(void)
{
	__try
	{
	if (m_pMappedFileBase)
		UnmapViewOfFile(m_pMappedFileBase);
	m_pMappedFileBase = 0;

	if (m_hFileMapping)
    	CloseHandle(m_hFileMapping);
	m_hFileMapping = 0;
	
    if ((m_hFile != INVALID_HANDLE_VALUE) && (m_hFile != 0))
		CloseHandle(m_hFile);
	m_hFile = 0;
	
	m_pDOSHeader   = 0;
	m_pImgFileHdr  = 0;
	m_pNTHeaders32 = 0;
	m_pNTHeaders64 = 0;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{}
}

BOOL PEFile::IsValidPEFile(void)
{
	BOOL rc = FALSE;

	__try 
	{	
		if (IsOpen())
		{
			if ((m_pDOSHeader->e_magic == IMAGE_DOS_SIGNATURE) &&	
				(m_pNTHeaders32->Signature == IMAGE_NT_SIGNATURE))
			{
				rc = TRUE;
			}
		}
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{}

	return rc;
}


wstring PEFile::DumpHashInformation( HashTransformation& hash, PBYTE pcbDiskHash,
                          PBYTE pcbMemoryHash, SIZE_T nHashSize )
{
    return DumpHash( pcbDiskHash, nHashSize );
}

BOOL PEFile::CalculateHash( HashTransformation& hash,
            PVOID pMessage, SIZE_T nMessageSize,
            PBYTE pcbHashBuffer, SIZE_T nHashBufferSize )
{
	__try {
				
    if( nHashBufferSize != hash.DigestSize() )
    {
        ZeroMemory( pcbHashBuffer, nHashBufferSize );
        return FALSE;
    }

    hash.Update( (const PBYTE)pMessage, nMessageSize );
    hash.Final( pcbHashBuffer );

    return TRUE;
	}
	    __except( EXCEPTION_EXECUTE_HANDLER ) {
    }
}

BOOL PEFile::Is64Bit()
{
	BOOL rc = FALSE;

	__try 
	{
		if (IsOpen())
		{
			if (m_pNTHeaders32->OptionalHeader.Magic == 
						IMAGE_NT_OPTIONAL_HDR64_MAGIC)
			{
				rc = TRUE;
			}
		}
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{}

	return rc;
}


BOOL PEFile::GetSectionHdrByName(char *szSection)
{

	bool bres = FALSE;

	if (Is64Bit())
			{
			
				IMAGE_SECTION_HEADER *pSection = IMAGE_FIRST_SECTION(m_pNTHeaders64);

		for (unsigned int i = 0; 
		 i < m_pNTHeaders64->FileHeader.NumberOfSections; 
		 i++, pSection++)
	{
		if (0 == strncmp((char *)pSection->Name, szSection, IMAGE_SIZEOF_SHORT_NAME))
			bres = TRUE;
	}
	}	

	else
	{

		IMAGE_SECTION_HEADER *pSection = IMAGE_FIRST_SECTION(m_pNTHeaders32);

	for (unsigned int i = 0; 
		 i < m_pNTHeaders32->FileHeader.NumberOfSections; 
		 i++, pSection++)
	{
		if (0 == strncmp((char *)pSection->Name, szSection, IMAGE_SIZEOF_SHORT_NAME))
			bres = TRUE;
	}
	}
	return bres;

}


VOID PEFile::GatherDiskImageInformation( LPCWSTR szFilename, PVOID& pBaseAddress, DWORD& dwRawData,
        PVOID& pEntryPoint, PVOID& pCodeStart, SIZE_T& dwCodeSize, PVOID& pCodeEnd )
{
    __try {
        hFile = m_hFile;

        if ( hFile == INVALID_HANDLE_VALUE )
        {
            __leave;
        }

        hFileMapping = m_hFileMapping;

		if ( NULL == hFileMapping )
        {
            __leave;
        }

        pBaseAddress = m_pMappedFileBase;

        if ( NULL == pBaseAddress )
        {
            __leave;
        }

        PIMAGE_DOS_HEADER pDOSHeader = NULL;
        pDOSHeader = static_cast<PIMAGE_DOS_HEADER>( pBaseAddress );
        if( pDOSHeader->e_magic != IMAGE_DOS_SIGNATURE )
        {
            __leave;
        }


		if(!Is64Bit())
		{
		if( m_pNTHeaders32->Signature != IMAGE_NT_SIGNATURE )
        {
            __leave;
        }


        PIMAGE_FILE_HEADER pFileHeader = NULL;
        pFileHeader = reinterpret_cast<PIMAGE_FILE_HEADER>(
            (PBYTE)&m_pNTHeaders32->FileHeader );

        PIMAGE_OPTIONAL_HEADER pOptionalHeader = NULL;
        pOptionalHeader = reinterpret_cast<PIMAGE_OPTIONAL_HEADER>(
            (PBYTE)&m_pNTHeaders32->OptionalHeader );

        if( IMAGE_NT_OPTIONAL_HDR32_MAGIC != m_pNTHeaders32->OptionalHeader.Magic )
        {
            __leave;
        }

        PIMAGE_SECTION_HEADER pSectionHeader = NULL;
        pSectionHeader = reinterpret_cast<PIMAGE_SECTION_HEADER>(
            (PBYTE)&m_pNTHeaders32->OptionalHeader +
           m_pNTHeaders32->FileHeader.SizeOfOptionalHeader );

        DWORD dwEntryPoint = m_pNTHeaders32->OptionalHeader.AddressOfEntryPoint;
        UINT nSectionCount = m_pNTHeaders32->FileHeader.NumberOfSections;

		for( UINT i = 0; i < nSectionCount; i++ )
        {
			if( pSectionHeader->VirtualAddress <= dwEntryPoint &&
                dwEntryPoint < pSectionHeader->VirtualAddress +
                               pSectionHeader->Misc.VirtualSize )
            
			{ break; }
            
            pSectionHeader++;
        }
        
        dwRawData = pSectionHeader->PointerToRawData;
           
        pCodeStart = (PVOID)((PBYTE)pBaseAddress +
            pSectionHeader->PointerToRawData );

        pEntryPoint = (PVOID)(((PBYTE)pBaseAddress) + dwEntryPoint);

		dwCodeSize = pSectionHeader->Misc.VirtualSize;

        pCodeEnd = (PVOID)((PBYTE)pCodeStart +
            pSectionHeader->Misc.VirtualSize );
		}

		else 
			if(Is64Bit())
		{
        if( m_pNTHeaders64->Signature != IMAGE_NT_SIGNATURE )
        {
            __leave;
        }

        PIMAGE_FILE_HEADER pFileHeader = NULL;
        pFileHeader = reinterpret_cast<PIMAGE_FILE_HEADER>(
            (PBYTE)&m_pNTHeaders64->FileHeader );

        PIMAGE_OPTIONAL_HEADER pOptionalHeader = NULL;
        pOptionalHeader = reinterpret_cast<PIMAGE_OPTIONAL_HEADER>(
            (PBYTE)&m_pNTHeaders64->OptionalHeader );

        if( IMAGE_NT_OPTIONAL_HDR64_MAGIC != m_pNTHeaders64->OptionalHeader.Magic )
        {
            __leave;
        }

        PIMAGE_SECTION_HEADER pSectionHeader = NULL;
        pSectionHeader = reinterpret_cast<PIMAGE_SECTION_HEADER>(
            (PBYTE)&m_pNTHeaders64->OptionalHeader +
            m_pNTHeaders64->FileHeader.SizeOfOptionalHeader );

        DWORD dwEntryPoint = m_pNTHeaders64->OptionalHeader.AddressOfEntryPoint;
        UINT nSectionCount = m_pNTHeaders64->FileHeader.NumberOfSections;
		
		for( UINT i = 0; i < nSectionCount; i++ )
        {
            if( pSectionHeader->VirtualAddress <= dwEntryPoint &&
                dwEntryPoint < pSectionHeader->VirtualAddress +
                               pSectionHeader->Misc.VirtualSize )
            { break; }
            
            pSectionHeader++;
        }
         
        dwRawData = pSectionHeader->PointerToRawData;

        pCodeStart = (PVOID)((PBYTE)pBaseAddress +
            pSectionHeader->PointerToRawData );

        pEntryPoint = (PVOID)(((PBYTE)pBaseAddress) + dwEntryPoint);

        dwCodeSize = pSectionHeader->Misc.VirtualSize;

        pCodeEnd = (PVOID)((PBYTE)pCodeStart +
            pSectionHeader->Misc.VirtualSize );
		}
      
    }
    __except( EXCEPTION_EXECUTE_HANDLER ) {
    }
}                         

std::wstring s2ws(const std::string& s)
{
 int len;
 int slength = (int)s.length() + 1;
 len = MultiByteToWideChar(CP_ACP, 0, s.c_str(), slength, 0, 0); 
 wchar_t* buf = new wchar_t[len];
 MultiByteToWideChar(CP_ACP, 0, s.c_str(), slength, buf, len);
 std::wstring r(buf);
 delete[] buf;
 return r;
}

wstring PEFile::DumpHash( PBYTE pcbHash, SIZE_T nHashSize )
{
	string final;

    StringSource(
        pcbHash,
        nHashSize,
        true,
        new HexEncoder(
            new StringSink( final ),
            false,
            0
        )
    );

	std::wstring stemp = s2ws(final); 

    return stemp;
}


int PEFile::IsSigned(TCHAR* filename)
{
   GUID guidAction = WINTRUST_ACTION_GENERIC_VERIFY_V2;
   WINTRUST_FILE_INFO sWintrustFileInfo;
   WINTRUST_DATA      sWintrustData;
   HRESULT            hr;

   memset((void*)&sWintrustFileInfo, 0x00, sizeof(WINTRUST_FILE_INFO));
   memset((void*)&sWintrustData, 0x00, sizeof(WINTRUST_DATA));

   sWintrustFileInfo.cbStruct = sizeof(WINTRUST_FILE_INFO);
   sWintrustFileInfo.pcwszFilePath = filename;
   sWintrustFileInfo.hFile = NULL;

   sWintrustData.cbStruct            = sizeof(WINTRUST_DATA);
   sWintrustData.dwUIChoice          = WTD_UI_NONE;
   sWintrustData.fdwRevocationChecks = WTD_REVOKE_NONE;
   sWintrustData.dwUnionChoice       = WTD_CHOICE_FILE;
   sWintrustData.pFile               = &sWintrustFileInfo;
   sWintrustData.dwStateAction       = WTD_STATEACTION_VERIFY;

   hr = WinVerifyTrust((HWND)INVALID_HANDLE_VALUE, &guidAction, &sWintrustData);

   if (TRUST_E_NOSIGNATURE == hr)
   {
	   is_signed = 1;
	   return -1;
   }
   else if (TRUST_E_BAD_DIGEST == hr)
   {
	   is_signed = 2;
	   return 1;
   }
   else if (TRUST_E_PROVIDER_UNKNOWN == hr)
   {
	   is_signed = 2;
	   return 2;	   
   }
   else if (S_OK != hr)
   {
	   is_signed = 2;
	   return 3;
   }
   else
   {
	 is_signed = 0;
     return 0;
   }

   sWintrustData.dwUIChoice = WTD_UI_NONE;
   sWintrustData.dwStateAction = WTD_STATEACTION_CLOSE;
   WinVerifyTrust((HWND)INVALID_HANDLE_VALUE, &guidAction, &sWintrustData);

}


BOOL PEFile::IsProtectedWinFile(TCHAR* filename)
{
	return SfcIsFileProtected(NULL,filename);
}


wstring PEFile::TextSectionSHA256(TCHAR* filename)
{
	bool se = false;

    PVOID   pBaseAddress = NULL;        
    DWORD   dwRawData = 0;  
    PVOID   pDiskEntryPoint = NULL;
    PVOID   pDiskCodeStart = NULL;
    PVOID   pDiskCodeEnd = NULL;
    SIZE_T  dwDiskCodeSize = 0;

    HMODULE hModule = NULL;
    PVOID   pVirtualAddress = NULL;  

	SHA256 hash;
	BYTE cbDiskHash[ SHA256::DIGESTSIZE ];
	BYTE cbMemoryHash[ SHA256::DIGESTSIZE ];

    GatherDiskImageInformation( filename, pBaseAddress, dwRawData,
        pDiskEntryPoint, pDiskCodeStart,
        dwDiskCodeSize, pDiskCodeEnd );

	CalculateHash( hash, pDiskCodeStart, dwDiskCodeSize,
        cbDiskHash, sizeof( cbDiskHash ) );

	return DumpHashInformation( hash, cbDiskHash, cbMemoryHash,
								sizeof( cbDiskHash ) );
}


DWORD Rva2Offset(DWORD dwRva, PIMAGE_SECTION_HEADER dwSectionRva, USHORT uNumberOfSections)
{
    for (USHORT i=0; i<uNumberOfSections; i++)
    {
        if (dwRva >= dwSectionRva->VirtualAddress)
        {
            if (dwRva < dwSectionRva->VirtualAddress + dwSectionRva->Misc.VirtualSize)
            {
                return (DWORD)(dwRva - dwSectionRva->VirtualAddress + dwSectionRva->PointerToRawData) ;
            }
        }
        dwSectionRva ++ ;
    }
    return (DWORD)-1 ;
}


BOOL PEFile::MapFileRead(char *SearchStr)
{
    USHORT uNumberOfSections ;
    DWORD  dwFileSize;
    DWORD  dwImportTableVirtualAddress ;
    DWORD  dwImportTableVirtualSize ;
    LPVOID lpView;
    PIMAGE_DATA_DIRECTORY pimage_data_directory ;
    PIMAGE_OPTIONAL_HEADER pimage_optional_header ;
    PIMAGE_IMPORT_DESCRIPTOR pimage_import_desciptor ;
    PIMAGE_SECTION_HEADER pimage_import_section_header ;
    PIMAGE_THUNK_DATA pimage_thunk_data ;
    PIMAGE_IMPORT_BY_NAME pimage_import_by_name ;
    PIMAGE_SECTION_HEADER pimage_section_header ;
	BOOL res = FALSE;

    dwFileSize = GetFileSize(m_hFile, NULL);
    if (INVALID_FILE_SIZE == dwFileSize)
    {
        CloseHandle(hFile);
        return -1;
    }
   
    if (NULL == m_hFileMapping)
    {
        CloseHandle(hFile);
        return -1;
    }

	
    lpView = (LPTSTR)MapViewOfFile(m_hFileMapping, FILE_MAP_READ, 0, 0, 0);
   
	if (m_pDOSHeader->e_magic == IMAGE_DOS_SIGNATURE)
    {
        m_pNTHeaders32 = (PIMAGE_NT_HEADERS) ((DWORD)lpView + m_pDOSHeader->e_lfanew) ;
    }
    else return NULL;
    if (m_pNTHeaders32->Signature == IMAGE_NT_SIGNATURE)
    {
        uNumberOfSections  =m_pNTHeaders32->FileHeader.NumberOfSections ;
    }
    else return -1;   
	
    pimage_optional_header = &m_pNTHeaders32->OptionalHeader ;
    pimage_data_directory = pimage_optional_header->DataDirectory ;
    ++pimage_data_directory;  
    dwImportTableVirtualAddress = pimage_data_directory->VirtualAddress ;
    dwImportTableVirtualSize = pimage_data_directory->Size ;
    pimage_section_header = (PIMAGE_SECTION_HEADER) ((DWORD) lpView + m_pDOSHeader->e_lfanew + sizeof(m_pNTHeaders32)) ;
    pimage_import_section_header = pimage_section_header ;
    if (dwImportTableVirtualSize != 0)
    {
        pimage_import_desciptor  = (PIMAGE_IMPORT_DESCRIPTOR)((DWORD) lpView + Rva2Offset(dwImportTableVirtualAddress, pimage_import_section_header, uNumberOfSections)) ;
        while (pimage_import_desciptor->Name != NULL)
        {
            if (pimage_import_desciptor->OriginalFirstThunk != 0)
            {
                pimage_thunk_data   = (PIMAGE_THUNK_DATA) ((DWORD) lpView + Rva2Offset(pimage_import_desciptor->OriginalFirstThunk, pimage_import_section_header, uNumberOfSections)) ;
            }
            else
            {
                pimage_thunk_data   = (PIMAGE_THUNK_DATA) ((DWORD) lpView + Rva2Offset(pimage_import_desciptor->FirstThunk, pimage_import_section_header, uNumberOfSections)) ;
            }
            while (pimage_thunk_data->u1.Ordinal != 0)
            {
                pimage_import_by_name  = (PIMAGE_IMPORT_BY_NAME) ((DWORD) lpView + Rva2Offset(pimage_thunk_data->u1.Function, pimage_import_section_header, uNumberOfSections)) ;
                if (pimage_thunk_data->u1.Ordinal & IMAGE_ORDINAL_FLAG32)
                {
                }
                else
                {
				char *ingX = (char *)pimage_import_by_name->Name;
				
				if( strcmp(ingX,SearchStr) == 0)
					{
					res = TRUE;
				}

                }
                pimage_thunk_data ++ ;
            }
            pimage_import_desciptor ++ ;
        }
    }
    else
    {
		//No IAT found
    }
   CloseHandle(m_hFileMapping);
   CloseHandle(hFile);
    return res;
}


DWORD PEFile::GetChecksum()
{
	DWORD rc = 0;

	__try 
	{
		if (IsOpen())
		{
			if (Is64Bit())
			{
				IMAGE_OPTIONAL_HEADER64 *pHdr = &m_pNTHeaders64->OptionalHeader;
				rc = pHdr->CheckSum;
				
			}
			else
			{
				IMAGE_OPTIONAL_HEADER32 *pHdr = &m_pNTHeaders32->OptionalHeader;
				rc = pHdr->CheckSum;
			}
		}
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{}

	return rc;
}


DWORD PEFile::CalculateChecksum()
{
	DWORD rc = 0;

	__try 
	{
		if (IsOpen())
		{
			DWORD dwSize = GetFileSize(m_hFile, NULL);
			if (dwSize != INVALID_FILE_SIZE)
			{
				DWORD dwHeaderSum = 0;
				DWORD dwCheckSum = 0;
				IMAGE_NT_HEADERS *pNTHeaders = 
					::CheckSumMappedFile(m_pMappedFileBase, 
										 dwSize, 
										 &dwHeaderSum,	// original checksum
										 &dwCheckSum);	// calculated checksum

				if (pNTHeaders)
				{
					rc = dwCheckSum;
				}
			}
		}
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{}

	return rc;
}


int PEFile::GetMaliciousActivity(int heur_level)
{
	bool found;
	DWORD aoep;
	time_t ltime;
    time (&ltime);
    double elapsed_time = difftime(ltime,time_t(0));

	if ( is_signed == 1)
		heur_sum += 20; //No valid signature found

	if ( is_signed == 2)
		heur_sum += 42; //Signature found, but it is invalid
	
	__try
	{
		if (IsOpen())
		{
			if( !Is64Bit() )
			{
				aoep = m_pNTHeaders32->OptionalHeader.AddressOfEntryPoint;

				for (unsigned int i = 0; i < m_pNTHeaders32->FileHeader.NumberOfSections; i++,  m_pNTSHeader++) 
					{
						if (aoep >= m_pNTSHeader->VirtualAddress || (aoep < (m_pNTSHeader->VirtualAddress + m_pNTSHeader->Misc.VirtualSize)))
						{
							heur_sum += 30; //Suspicious PE Entry Point
							break;
						}
					}
			
			}
	else
		if( Is64Bit() )
			{
				aoep = m_pNTHeaders64->OptionalHeader.AddressOfEntryPoint;
	
				for (unsigned int i = 0; i < m_pNTHeaders64->FileHeader.NumberOfSections; i++,  m_pNTSHeader++) 
				{
					if (aoep >= m_pNTSHeader->VirtualAddress || (aoep < (m_pNTSHeader->VirtualAddress + m_pNTSHeader->Misc.VirtualSize)))
					{
						heur_sum += 30; //Suspicious PE Entry Point
						break;
					}
				}
			}
		}
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
	}

	if ( m_pImgFileHdr->TimeDateStamp > elapsed_time)
		heur_sum += 5; //It is suspicious if ImageFileHeader TimeDateStamp is greater than current timedate

	if ((GetChecksum() != 0) && (GetChecksum() != CalculateChecksum()))
		heur_sum += 30; //Calculated checksum does not match the one in the file header

	if (heur_sum >= heur_level)
		return heur_sum;
	else	
		return 1;
}

PEFile::~PEFile(void)
{
}
