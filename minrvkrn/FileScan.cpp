#include "StdAfx.h"
#include <tchar.h>
#include "FileScan.h"
#include "PEFile.h"
#include "DB.h"

using namespace std;

FileScan::FileScan(void)
{
}


std::wstring s2ws(const std::string& s)
{
 int len;
 int slength = (int)s.length() + 1;
 len = MultiByteToWideChar(CP_ACP, 0, s.c_str(), slength, 0, 0); 
 wchar_t* buf = new wchar_t[len];
 MultiByteToWideChar(CP_ACP, 0, s.c_str(), slength, buf, len);
 std::wstring r(buf);
 delete[] buf;
 return r;
}


int FileScan::Scan(TCHAR* filename, int heur_level)
{
	
	PEFile pefile;

	wstring query0, query1;
	wstring q1,q2,q3,q4,q5,q6,q7;
	wstring status;

	q1 = _T("select detectionname from `blacklist-generic` where match(sectionsha256) against ('");
	q3 = _T("')");

	q5 = _T("select detectionname from `blacklist-exact` where match(filesha256) against ('");

	pefile.OpenFile(filename);
	
	if ( pefile.IsValidPEFile() && !pefile.IsProtectedWinFile(filename) )
	{
		int mal_act = pefile.GetMaliciousActivity(heur_level);

		if ( mal_act < 40 ) {
			q2 = pefile.TextSectionSHA256(filename);
			if(q2.length() > 20 )
			{
				q4 = q1+q2+q3;

				query0 = dbhandle.ExecuteQuery(q4);
			
				if(query0.length() > 0) 
				{
					pefile.CloseFile();
					return 100;
				}
				else 
				{
					pefile.CloseFile();
					return 0;
				}
		}
			else return 0;
		}
		else 
		{
				pefile.CloseFile();
				return mal_act;
		}
		pefile.CloseFile();
	}

	else 
		if(!pefile.IsValidPEFile())
		{
			q6 = pefile.FileSHA256Hash(filename);
			if(q6.length() > 20 )
			{
			q7 = q5 + q6 + q3;

			query1 = dbhandle.ExecuteQuery(q7);
		
			if(query1.length() > 0)
				return 100;
			else return 0;
			}
			else return 0;
		}
}

FileScan::~FileScan(void)
{
}
