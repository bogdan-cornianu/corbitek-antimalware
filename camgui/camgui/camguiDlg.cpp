
// camguiDlg.cpp : implementation file
//
#include "stdafx.h"
#include "camgui.h"
#include "camguiDlg.h"
#include "ThreatDlg.h"
#include <string>
#include "afxdialogex.h"
#include "afxwin.h"

using namespace std;

#pragma comment(lib,"kernel32.lib")

#ifdef _DEBUG
#define new DEBUG_NEW
#endif


// CAboutDlg dialog used for App About

class CAboutDlg : public CDialogEx
{
public:
	CAboutDlg();

// Dialog Data
	enum { IDD = IDD_ABOUTBOX };

	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Implementation
protected:
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialogEx(CAboutDlg::IDD)
{
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialogEx::DoDataExchange(pDX);
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialogEx)
END_MESSAGE_MAP()

// CcamguiDlg dialog




CcamguiDlg::CcamguiDlg(CWnd* pParent /*=NULL*/)
	: CDialogEx(CcamguiDlg::IDD, pParent)
{
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
	m_heurslidervalue = 0;
}

void CcamguiDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialogEx::DoDataExchange(pDX);
	DDX_Control(pDX, IDC_LIST2, m_malware);
	DDX_Control(pDX, IDC_PATH, m_path);
	DDX_Control(pDX, IDC_MFCEDITBROWSE2, m_browseedit);
	DDX_Control(pDX, IDC_BUTTON1, m_stopbtn);
	DDX_Control(pDX, IDC_FOUND, m_found);
	DDX_Control(pDX, IDC_SCANNED, m_scanned);
	DDX_Control(pDX, IDC_HOSTNAME, hostname);
	DDX_Control(pDX, IDC_EDITHOSTNAME, edithostname);
	//  DDX_Control(pDX, IDC_REFRESHDB, refreshdbbtn);
	DDX_Control(pDX, IDC_HEURLBL, m_heurlabel);
	DDX_Control(pDX, IDC_SLIDER1, m_heurslider);
	DDX_Slider(pDX, IDC_SLIDER1, m_heurslidervalue);
	DDV_MinMaxInt(pDX, m_heurslidervalue, 10, 100);
}

BEGIN_MESSAGE_MAP(CcamguiDlg, CDialogEx)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	ON_BN_CLICKED(IDCANCEL, &CcamguiDlg::OnBnClickedCancel)
	ON_BN_CLICKED(IDOK, &CcamguiDlg::OnBnClickedOk)
	ON_EN_CHANGE(IDC_MFCEDITBROWSE2, &CcamguiDlg::OnEnChangeMfceditbrowse2)
	ON_BN_CLICKED(IDC_BUTTON1, &CcamguiDlg::OnBnClickedButton1)
	ON_STN_CLICKED(IDC_FOUND, &CcamguiDlg::OnStnClickedFound)
	ON_BN_CLICKED(IDC_REFRESHDB, &CcamguiDlg::OnBnClickedRefreshdb)
//	ON_MESSAGE(sendFileName, &CcamguiDlg::OnSendfilename)
ON_STN_CLICKED(IDC_PICTURE, &CcamguiDlg::OnStnClickedPicture)
ON_STN_CLICKED(IDC_HOSTNAME, &CcamguiDlg::OnStnClickedHostname)
ON_BN_CLICKED(IDC_MFCBUTTON1, &CcamguiDlg::OnBnClickedMfcbutton1)
ON_COMMAND(ID_FILE_EXIT, &CcamguiDlg::OnFileExit)
ON_COMMAND(ID_HELP_ABOUT, &CcamguiDlg::OnHelpAbout)
ON_COMMAND(ID_HELP_HELP, &CcamguiDlg::OnHelpHelp)
END_MESSAGE_MAP()


// CcamguiDlg message handlers

typedef int (*MalSumFunc)(TCHAR*, int);
typedef void (*CTDBFunc)(const char*, const char*, const char*);
typedef void (*DFDBFunc)(void);
typedef bool (*RemoveThreatFunc)(TCHAR*);

MalSumFunc msf;
CTDBFunc ctdbf;
DFDBFunc dfdbf;
RemoveThreatFunc remthreat;
HINSTANCE hInstLibrary = LoadLibrary(_T("minrvkrn.dll"));

int msum = 0;

void CcamguiDlg::setFileName(CString fn)
{
	this->filename = fn;
}

CString CcamguiDlg::getFileName()
{
	return this->filename;
}

BOOL CcamguiDlg::OnInitDialog()
{
	CDialogEx::OnInitDialog();

	// Add "About..." menu item to system menu.

	// IDM_ABOUTBOX must be in the system command range.
	ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
	ASSERT(IDM_ABOUTBOX < 0xF000);

	CMenu* pSysMenu = GetSystemMenu(FALSE);
	if (pSysMenu != NULL)
	{
		BOOL bNameValid;
		CString strAboutMenu;
		bNameValid = strAboutMenu.LoadString(IDS_ABOUTBOX);
		ASSERT(bNameValid);
		if (!strAboutMenu.IsEmpty())
		{
			pSysMenu->AppendMenu(MF_SEPARATOR);
			pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
		}
	}

	// Set the icon for this dialog.  The framework does this automatically
	//  when the application's main window is not a dialog
	SetIcon(m_hIcon, TRUE);			// Set big icon
	SetIcon(m_hIcon, FALSE);		// Set small icon

	selectedaction = -1;

	bStop = FALSE;

	LVCOLUMN lvColumn;
	int nCol;

	m_malware.DeleteAllItems();
	m_malware.DeleteColumn(0);

	lvColumn.mask = LVCF_FMT | LVCF_TEXT | LVCF_WIDTH;
	lvColumn.fmt = LVCFMT_LEFT;
	lvColumn.cx = 250;
	lvColumn.pszText = _T("File Name");
	nCol = m_malware.InsertColumn(0, &lvColumn);

	lvColumn.mask = LVCF_FMT | LVCF_TEXT | LVCF_WIDTH;
	lvColumn.fmt = LVCFMT_LEFT;
	lvColumn.cx = 130;
	lvColumn.pszText = _T("Malicious Activity");
	m_malware.InsertColumn(1, &lvColumn);

	lvColumn.mask = LVCF_FMT | LVCF_TEXT | LVCF_WIDTH;
	lvColumn.fmt = LVCFMT_LEFT;
	lvColumn.cx = 110;
    lvColumn.pszText = _T("Action");
	m_malware.InsertColumn(2, &lvColumn);

	// TODO: Add extra initialization here

	if (hInstLibrary)
	{
		msf = (MalSumFunc)GetProcAddress(hInstLibrary, "MalSum");
		ctdbf = (CTDBFunc)GetProcAddress(hInstLibrary, "ConnectToDB");
		dfdbf = (DFDBFunc)GetProcAddress(hInstLibrary, "DisconnectFromDB");
		remthreat = (RemoveThreatFunc)GetProcAddress(hInstLibrary, "RemoveThreat");
	}

	hostname.SetWindowTextW(_T("Database Server"));
	m_found.SetWindowTextW(_T("Found: 0"));
	m_scanned.SetWindowTextW(_T("Scanned: 0"));
	edithostname.SetWindowTextW(_T("localhost"));
	m_heurslider.SetRangeMin(10);
	m_heurslider.SetRangeMax(100);
	m_heurslider.SetSelection(10,100);
	m_heurslider.SetTicFreq(30);
	m_heurslider.SetPos(40);
	m_heurlabel.SetWindowTextW(_T("Heuristics: "));
		
	sfiles = 0;
	found = 0;

	try
	{
	ctdbf("localhost","camclient","public");
	} catch (...) {
	MessageBox(_T("Unable to connect to Database Server!"),_T("DBConnection Error"),MB_ICONERROR);
	}

	return TRUE;  // return TRUE  unless you set the focus to a control
}

void CcamguiDlg::OnSysCommand(UINT nID, LPARAM lParam)
{
	if ((nID & 0xFFF0) == IDM_ABOUTBOX)
	{
		CAboutDlg dlgAbout;
		dlgAbout.DoModal();
	}
	else
	{
		CDialogEx::OnSysCommand(nID, lParam);
	}
}

// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CcamguiDlg::OnPaint()
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, reinterpret_cast<WPARAM>(dc.GetSafeHdc()), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialogEx::OnPaint();
	}
}

void CcamguiDlg::OnCancel() 
{
   // TODO: Add extra cleanup here
   
   // Ensure that you reset all the values back to the
   // ones before modification. This handler is called
   // when the user doesn't want to save the changes.
   
   //bres = FreeLibrary(hMod);
	bStop = TRUE;
	dfdbf(); //Close database connection
	FreeLibrary(hInstLibrary);
   CDialog::OnCancel();
}

// The system calls this function to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CcamguiDlg::OnQueryDragIcon()
{
	return static_cast<HCURSOR>(m_hIcon);
}



void CcamguiDlg::OnBnClickedCancel()
{
	bStop = TRUE;
	CDialogEx::OnCancel();
}


void CcamguiDlg::OnBnClickedMfcmenubutton3()
{
}


void CcamguiDlg::OnBnClickedOk()
{
	CDialogEx::OnOK();
}


void CcamguiDlg::OnTcnSelchangeTab1(NMHDR *pNMHDR, LRESULT *pResult)
{
	*pResult = 0;
}

void CcamguiDlg::Recurse(LPCTSTR pstr)
{
   CFileFind finder;
   CThreatDlg threatdlg;
   CString strWildcard(pstr);
   CString gfn;
   strWildcard += _T("\\*.*");
   MSG	msg;
   BOOL bWorking = finder.FindFile(strWildcard);
   TCHAR* szTest;                        
   LVITEM lvItem;
   int nItem, i = -1;
   CString sf, resultaction;
   CString scanned_files;

if(bStop == FALSE)
{
               
   while (bWorking)
   {
      bWorking = finder.FindNextFile();
	  CString str1 = finder.GetFilePath();
	  szTest = str1.GetBuffer(0);

	   if((finder.IsDirectory()) == FALSE)
	   {
		if(msf)
		{
			msum = msf(szTest,m_heurslider.GetPos());
		}
		
		   m_path.SetWindowTextW(str1);
		   m_path.RedrawWindow();

			sfiles += 1;

			scanned_files.Format(_T("Scanned: %d"),sfiles);
			UpdateData();
			m_scanned.SetWindowTextW(scanned_files);
			m_scanned.RedrawWindow();
			UpdateData(false);

		   while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
	{
		TranslateMessage(&msg);
		DispatchMessage(&msg);
	}

	if(msum >=30 )
	{
	found += 1;
    lvItem.mask = LVIF_TEXT;
	lvItem.iItem = i + 1;
	lvItem.iSubItem = 0;
	int length = 1024;
	CString lol = finder.GetFileName();
	LPWSTR pwsz = lol.GetBuffer(length);
	lvItem.pszText = pwsz;
	lol.ReleaseBuffer();
	nItem = m_malware.InsertItem(&lvItem);
	setFileName(finder.GetFileName());

	if((msum >= 30) && (msum < 50))
	{
	m_malware.SetItemText(nItem, 1, _T("Low"));
	m_malware.SetItemText(nItem, 2, _T("Report Only"));

	if(selectedaction == -1)
	{
	threatdlg.DoModal();
	selectedaction = threatdlg.check;

	if(threatdlg.m_autodecidevalue == 1)
	{
		if(remthreat(szTest))
		{
			m_malware.SetItemText(nItem, 2, _T("Deleted"));
		}
		else
		if(!remthreat(szTest))
		{
			m_malware.SetItemText(nItem, 2, _T("Delete Failed!"));
			MessageBox(_T("Error deleting file!"),_T("Error"),MB_ICONERROR);
		}
	}
	else
		if(threatdlg.m_autodecidevalue == 2)
		{
			m_malware.SetItemText(nItem, 2, _T("Ignored"));
		}
		else
			if(threatdlg.m_autodecidevalue == 0)
			{
				if(remthreat(szTest))
				{
					m_malware.SetItemText(nItem, 2, _T("Deleted"));
				}
				else
					if(!remthreat(szTest))
					{
						m_malware.SetItemText(nItem, 2, _T("Delete Failed!"));
						MessageBox(_T("Error deleting file!"),_T("Error"),MB_ICONERROR);
					}
			}
}
	else
		if(selectedaction != -1)
		{
			if(selectedaction == 1)
			{
			if(remthreat(szTest))
			{
				m_malware.SetItemText(nItem, 2, _T("Deleted"));
			}
			else
			if(!remthreat(szTest))
			{
				m_malware.SetItemText(nItem, 2, _T("Delete Failed!"));
				MessageBox(_T("Error deleting file!"),_T("Error"),MB_ICONERROR);
			}
		}
		else
			if(selectedaction == 2)
			{
				m_malware.SetItemText(nItem, 2, _T("Ignored"));
			}
			else
				if(selectedaction == 0)
				{
					if(remthreat(szTest))
					{
						m_malware.SetItemText(nItem, 2, _T("Deleted"));
					}
					else
						if(!remthreat(szTest))
						{
							m_malware.SetItemText(nItem, 2, _T("Delete Failed!"));
							MessageBox(_T("Error deleting file!"),_T("Error"),MB_ICONERROR);
						}
				}
		}
	}else
		if((msum >= 50) && (msum < 75))
		{
			m_malware.SetItemText(nItem, 1, _T("MEDIUM"));
	
	
					if(selectedaction == -1)
					{
					threatdlg.DoModal();
					selectedaction = threatdlg.check;
	
					if(threatdlg.m_autodecidevalue == 1)
					{
						if(remthreat(szTest))
						{
							m_malware.SetItemText(nItem, 2, _T("Deleted"));
						}
						else
						if(!remthreat(szTest))
						{
							m_malware.SetItemText(nItem, 2, _T("Delete Failed!"));
							MessageBox(_T("Error deleting file!"),_T("Error"),MB_ICONERROR);
						}
					}
					else
						if(threatdlg.m_autodecidevalue == 2)
						{
							m_malware.SetItemText(nItem, 2, _T("Ignored"));
						}
						else
							if(threatdlg.m_autodecidevalue == 0)
							{
								if(remthreat(szTest))
								{
									m_malware.SetItemText(nItem, 2, _T("Deleted"));
								}
								else
									if(!remthreat(szTest))
									{
										m_malware.SetItemText(nItem, 2, _T("Delete Failed!"));
										MessageBox(_T("Error deleting file!"),_T("Error"),MB_ICONERROR);
									}
							}
				}
					else
						if(selectedaction != -1)
						{
							if(selectedaction == 1)
							{
							if(remthreat(szTest))
							{
								m_malware.SetItemText(nItem, 2, _T("Deleted"));
							}
							else
							if(!remthreat(szTest))
							{
								m_malware.SetItemText(nItem, 2, _T("Delete Failed!"));
								MessageBox(_T("Error deleting file!"),_T("Error"),MB_ICONERROR);
							}
						}
						else
							if(selectedaction == 2)
							{
								m_malware.SetItemText(nItem, 2, _T("Ignored"));
							}
							else
								if(selectedaction == 0)
								{
									if(remthreat(szTest))
									{
										m_malware.SetItemText(nItem, 2, _T("Deleted"));
									}
									else
										if(!remthreat(szTest))
										{
											m_malware.SetItemText(nItem, 2, _T("Delete Failed!"));
											MessageBox(_T("Error deleting file!"),_T("Error"),MB_ICONERROR);
										}
								}
						}
	}else
			if((msum >= 75) && (msum < 90))
			{
				m_malware.SetItemText(nItem, 1, _T("HIGH"));
		
					if(selectedaction == -1)
					{
					threatdlg.DoModal();
					selectedaction = threatdlg.check;
	
					if(threatdlg.m_autodecidevalue == 1)
					{
						if(remthreat(szTest))
						{
							m_malware.SetItemText(nItem, 2, _T("Deleted"));
						}
						else
						if(!remthreat(szTest))
						{
							m_malware.SetItemText(nItem, 2, _T("Delete Failed!"));
							MessageBox(_T("Error deleting file!"),_T("Error"),MB_ICONERROR);
						}
					}
					else
						if(threatdlg.m_autodecidevalue == 2)
						{
							m_malware.SetItemText(nItem, 2, _T("Ignored"));
						}
						else
							if(threatdlg.m_autodecidevalue == 0)
							{
								if(remthreat(szTest))
								{
									m_malware.SetItemText(nItem, 2, _T("Deleted"));
								}
								else
									if(!remthreat(szTest))
									{
										m_malware.SetItemText(nItem, 2, _T("Delete Failed!"));
										MessageBox(_T("Error deleting file!"),_T("Error"),MB_ICONERROR);
									}
							}
				}
					else
						if(selectedaction != -1)
						{
							if(selectedaction == 1)
							{
							if(remthreat(szTest))
							{
								m_malware.SetItemText(nItem, 2, _T("Deleted"));
							}
							else
							if(!remthreat(szTest))
							{
								m_malware.SetItemText(nItem, 2, _T("Delete Failed!"));
								MessageBox(_T("Error deleting file!"),_T("Error"),MB_ICONERROR);
							}
						}
						else
							if(selectedaction == 2)
							{
								m_malware.SetItemText(nItem, 2, _T("Ignored"));
							}
							else
								if(selectedaction == 0)
								{
									if(remthreat(szTest))
									{
										m_malware.SetItemText(nItem, 2, _T("Deleted"));
									}
									else
										if(!remthreat(szTest))
										{
											m_malware.SetItemText(nItem, 2, _T("Delete Failed!"));
											MessageBox(_T("Error deleting file!"),_T("Error"),MB_ICONERROR);
										}
								}
						}
			}else
				if((msum >= 90) && (msum <= 100))
				{
					m_malware.SetItemText(nItem, 1, _T("VERY HIGH"));

					if(selectedaction == -1)
					{
					threatdlg.DoModal();
					selectedaction = threatdlg.check;
	
					if(threatdlg.m_autodecidevalue == 1)
					{
						if(remthreat(szTest) == TRUE)
						{
							m_malware.SetItemText(nItem, 2, _T("Deleted"));
						}
						else
						if(remthreat(szTest) == FALSE)
						{
							m_malware.SetItemText(nItem, 2, _T("Delete Failed!"));
							MessageBox(_T("Error deleting file!"),_T("Error"),MB_ICONERROR);
						}
					}
					else
						if(threatdlg.m_autodecidevalue == 2)
						{
							m_malware.SetItemText(nItem, 2, _T("Ignored"));
						}
						else
							if(threatdlg.m_autodecidevalue == 0)
							{
								if(remthreat(szTest) == TRUE)
								{
									m_malware.SetItemText(nItem, 2, _T("Deleted"));
								}
								else
									if(remthreat(szTest) == FALSE)
									{
										m_malware.SetItemText(nItem, 2, _T("Delete Failed!"));
										MessageBox(_T("Error deleting file!"),_T("Error"),MB_ICONERROR);
									}
							}
				}
					else
						if(selectedaction != -1)
						{
							if(selectedaction == 1)
							{
							if(remthreat(szTest) == TRUE)
							{
								m_malware.SetItemText(nItem, 2, _T("Deleted"));
							}
							else
							if(remthreat(szTest) == FALSE)
							{
								m_malware.SetItemText(nItem, 2, _T("Delete Failed!"));
								MessageBox(_T("Error deleting file!"),_T("Error"),MB_ICONERROR);
							}
						}
						else
							if(selectedaction == 2)
							{
								m_malware.SetItemText(nItem, 2, _T("Ignored"));
							}
							else
								if(selectedaction == 0)
								{
									if(remthreat(szTest) == TRUE)
									{
										m_malware.SetItemText(nItem, 2, _T("Deleted"));
									}
									else
										if(remthreat(szTest) == FALSE)
										{
											m_malware.SetItemText(nItem, 2, _T("Delete Failed!"));
											MessageBox(_T("Error deleting file!"),_T("Error"),MB_ICONERROR);
										}
								}
						}
				}

	sf.Format(_T("Found: %d"),found);
	UpdateData();
	m_found.SetWindowTextW(sf);
	m_found.RedrawWindow();
	UpdateData(false);

	  }

	   }
      if (finder.IsDots())
         continue;

      if (finder.IsDirectory())
      {	
		CString str = finder.GetFilePath();
         Recurse(str);
      }

	    while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
	{
		TranslateMessage(&msg);
		DispatchMessage(&msg);
	}
   if(bStop == TRUE)
   {
	   break;
   }
   }
   finder.Close();
 }
}

void CcamguiDlg::OnEnChangeMfceditbrowse2()
{
	CString str, found_files;

	m_stopbtn.EnableWindow(TRUE);
	m_browseedit.GetWindowTextW(str);

	m_malware.DeleteAllItems();

	sfiles = 0;
	found = 0;

	found_files.Format(_T("Found: %d"),found);
			UpdateData();
			m_found.SetWindowTextW(found_files);
			m_found.RedrawWindow();
			UpdateData(false);

	Recurse(str);
	m_stopbtn.EnableWindow(FALSE);
	::MessageBoxExW(NULL,_T("Scan Finished!"),_T("Proiect Antivirus"),MB_ICONINFORMATION,0);
}



void CcamguiDlg::OnBnClickedButton1()
{
	selectedaction = -1;
	bStop = TRUE;
}


void CcamguiDlg::OnStnClickedFound()
{

}


void CcamguiDlg::OnBnClickedRefreshdb()
{
	CString hostname;
	edithostname.GetWindowTextW(hostname);
	CT2A ascii(hostname);

	try
	{
	dfdbf();
	ctdbf(ascii,"camclient","public");
	MessageBox(_T("Succesfully connected to the database server!"),_T("DBConnection Success"),MB_ICONINFORMATION);
	} catch (...) {
	MessageBox(_T("Unable to connect to Database Server!"),_T("DBConnection Error"),MB_ICONERROR);
	}
}



void CcamguiDlg::OnStnClickedPicture()
{
}


void CcamguiDlg::OnStnClickedHostname()
{
}


void CcamguiDlg::OnBnClickedMfcbutton1()
{
	CString hostname;
	edithostname.GetWindowTextW(hostname);
	CT2A ascii(hostname);

	try
	{
	dfdbf();
	ctdbf(ascii,"camclient","public");
	MessageBox(_T("Succesfully connected to Database Server!"),_T("DBConnection Success"),MB_ICONINFORMATION);
	} catch (...) {
	MessageBox(_T("Unable to connect to Database Server!"),_T("DBConnection Error"),MB_ICONERROR);
	}
}


void CcamguiDlg::OnFileExit()
{
	bStop = TRUE;
	dfdbf(); //Close database connection
	FreeLibrary(hInstLibrary);
    CDialog::OnCancel();
}


void CcamguiDlg::OnHelpAbout()
{
	CAboutDlg dlgAbout;
	dlgAbout.DoModal();
}


void CcamguiDlg::OnHelpHelp()
{
	ShellExecute(NULL, _T("open"), _T("Help.html"), NULL, NULL, SW_SHOWNORMAL);
}
